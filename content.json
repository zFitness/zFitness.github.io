{"meta":{"title":"ZFITNESS'S BLOG","subtitle":"当你凝视深渊时，深渊也在凝视着你。","description":"zfitness 的个人博客；主攻后端开发","author":"zfitness","url":"http://zfitness.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2020-02-25T02:34:35.804Z","updated":"2020-02-25T02:34:35.804Z","comments":true,"path":"404.html","permalink":"http://zfitness.github.io/404.html","excerpt":"","text":"404 Not Found **很抱歉，您访问的页面不存在** 可能是输入地址有误或该地址已被删除"},{"title":"关于","date":"2020-02-25T02:34:35.820Z","updated":"2020-02-25T02:34:35.820Z","comments":true,"path":"about/index.html","permalink":"http://zfitness.github.io/about/index.html","excerpt":"","text":"[][3] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [][4] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [][5] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [][6] 这是测试博客，请随意留言，但是我不会回复 关于主题本站主题是：Material X One More Thing懒加载占位图如果喜欢请拿去：图片链接 欢迎灌水 [1]: /about/ [2]: http://www.szhittech.com/ [3]: https://github.com/xaoxuu [4]: https://xaoxuu.com/blog/ [5]: https://instagram.com/xaoxuu [6]: https://music.163.com/#/user/home?id=63035382 [7]: mailto:me@xaoxuu.com"},{"title":"","date":"2020-02-25T02:34:35.835Z","updated":"2020-02-25T02:34:35.835Z","comments":true,"path":"projects/index.html","permalink":"http://zfitness.github.io/projects/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2020-02-25T02:34:35.820Z","updated":"2020-02-25T02:34:35.820Z","comments":true,"path":"friends/index.html","permalink":"http://zfitness.github.io/friends/index.html","excerpt":"","text":"各位大佬想交换友链的话可以在下方留言，必须要有名称、头像链接、和至少一个标签哦～ 名称： xaoxuu’s blog头像： https://img.vim-cn.com/76/c339fd7092750f472da9ad17bd7c0081a1f0e2.jpg网址： https://xaoxuu.com/blog/标签： iOS"},{"title":"所有标签","date":"2020-02-25T02:34:35.835Z","updated":"2020-02-25T02:34:35.835Z","comments":true,"path":"tags/index.html","permalink":"http://zfitness.github.io/tags/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2020-02-25T02:34:35.820Z","updated":"2020-02-25T02:34:35.820Z","comments":true,"path":"blog/categories/index.html","permalink":"http://zfitness.github.io/blog/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-02-25T02:34:35.820Z","updated":"2020-02-25T02:34:35.820Z","comments":true,"path":"blog/tags/index.html","permalink":"http://zfitness.github.io/blog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"java8","slug":"java8","date":"2020-02-29T02:58:30.000Z","updated":"2020-02-29T03:00:56.937Z","comments":true,"path":"2020/02/29/java8/","link":"","permalink":"http://zfitness.github.io/2020/02/29/java8/","excerpt":"","text":"java8 新特性1 Lambda表达式 lambda 是一个匿名函数， lambda 表达式基本语法： java8中引入了一个新的操作符：-&gt; lambda 操作符。 结构分为两部分： 左侧：lambda表达式的参数列表 右侧：Lambda表达式中需要执行的功能， lambda体 语法格式 语法格式一： 无参数，无返回值 () -&gt; {}， 例如： Runnable 语法格式二： 一个参数，无返回值， 小括号可以省略不写 (x) -&gt; {}, 例如： Consumer， 语法格式三：有两个以上参数，有返回值， 如果只有一条语句， return和大括号可以省略不写 (x, y) -&gt; {return }, 例如：Comparator 语法格式六：lambda的参数列表的数据类型可以省略， 因为JVM编译器通过上下文推断出，数据类型，即“类型推断”。 上联：左右遇一括号省, 下联：左侧推断类型省 横批： 能省则省 lambda表达式需要函数式接口支持。 2 ​​函数式接口函数式接口： 接口中只有一个抽象方法的接口， 可以使用 @FunctionalInterface 修饰。 2.1 java核心函数式接口 Consumer&lt;T&gt;: 消费型接口 void accept(T t); :accept: 12345678//Consumer&lt;T&gt; 消费型接口@Testpublic void test1() &#123; happy(1000, x -&gt; System.out.println(\"吃饭花了\" + x + \"元\"));&#125;public void happy(double money, Consumer&lt;Double&gt; consumer) &#123; consumer.accept(money);&#125; Supplier&lt;T&gt;： 供给型接口 T get(); 1234567891011121314@Testpublic void test2() &#123; List&lt;Integer&gt; list = getNumberlist(10, () -&gt; (int) (Math.random() * 100)); list.forEach(System.out::println);&#125;//需求：产生指定一些整数， 并放入集合中public List&lt;Integer&gt; getNumberlist(int num, Supplier&lt;Integer&gt; supplier) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; num; i++) &#123; list.add(supplier.get()); &#125; return list;&#125; Function&lt;T, R&gt; : 函数型接口 R apply(T t); 12345678//Function&lt;T,R&gt; 函数型接口@Testpublic void test3() &#123; System.out.println(getLength(\"ddd\", x -&gt; x.length()));&#125;public Integer getLength(String str, Function&lt;String, Integer&gt; function) &#123; return function.apply(str);&#125; Predicate&lt;T&gt;: 断言型接口 boolean test(T t) 123456789101112131415@Testpublic void test4() &#123; List&lt;String&gt; list = Arrays.asList(\"aaa\", \"bbb\", \"aa\"); List&lt;String&gt; filterList = filter(list, x -&gt; x.length() &gt; 2); filterList.forEach(System.out::println);&#125;public List&lt;String&gt; filter(List&lt;String&gt; list, Predicate&lt;String&gt; predicate) &#123; List&lt;String&gt; list1 = new ArrayList&lt;&gt;(); for (String s : list) &#123; if (predicate.test(s)) &#123; list1.add(s); &#125; &#125; return list1;&#125; 2.2 java 其他函数式接口 函数式接口 参数类型 返回类型 用途 BiFunction&lt;T,U,R&gt; T, U U 对类型为T,R 参数应用操作，返回 R 类型的结果。包含方法为 R apply(T t, U u) UnaryOperator&lt;T&gt; T T 对类型为T的对象进行一元运算，并返回T类型的结果。包含方法为 T apply(T t); BinaryOperator&lt;T&gt; T, T T 代表了一个作用于于两个同类型操作符的操作，并且返回了操作符同类型的结果。包含方法： T apply(T t1, T t2) BiConsumer&lt;T,U&gt; T, U void 代表了一个接受两个输入参数的操作，并且不返回任何结果。 void accept(T t, U u) ToIntFunction&lt;T&gt; ToLongFunction&lt;T&gt; ToDoubleFunction&lt;T&gt; T int long double 接受两个输入参数，分别返回一个int,long,double类型结果。 BiPredicate&lt;T,U&gt; T,U boolean 代表了对两个参数的断言操作（基于Boolean值的方法） 函数式接口通过一个单一的功能来表现。例如，带有单个compareTo方法的比较接口，被用于比较的场合。Java 8 开始定义了大量的函数式接口来广泛地用于lambda表达式。 12BiFunction&lt;Integer, Integer, Employee&gt; bf1 = (x, y) -&gt; new Employee(x, y); //返回第三个参数BiPredicate&lt;String, String&gt; bp = (x, y) -&gt; x.equals(y); //返回 boolean 3 引用3.1 方法引用:notebook:语法格式 对象:: 实例方法名: 12Consumer&lt;String&gt; con = (x) -&gt; System.out.println(x);Consumer&lt;String&gt; consumer = System.out::print; 类::静态方法名 1Supplier&lt;Double&gt; supplier = Math::random; 类:: 实例方法名 12BiPredicate&lt;String, String&gt; bp = (x, y) -&gt; x.equals(y);BiPredicate&lt;String, String&gt; bp1 = String::equals; lambda 体中调用方法的参数列表与返回值类型，要与函数式接口中抽象方法的函数列表和返回值类型保持一致。 若 lambda 参数列表中的第一参数是实例方法的调用者， 而第二个参数是实例方法的参数时,可以使用 ClassName::method 3.2 构造器引用格式： ClassName::new 实例： 无参数的构造器引用 1234//lambdaSupplier&lt;Employee&gt; sup = () -&gt; new Employee();//构造器引用Supplier&lt;Employee&gt; sup2 = Employee::new; 一个参数的构造器引用 123456//lambdaFunction&lt;Integer, Employee&gt; function = x -&gt; new Employee(x);function.apply(111);// 有1个参数的构造器引用Function&lt;Integer, Employee&gt; function1 = Employee::new;function1.apply(101); // return new Employee(101) 有2个参数的构造器引用 1234BiFunction&lt;Integer, Integer, Employee&gt; bf1 = (x, y) -&gt; new Employee(x, y);// 有2个参数的构造器引用BiFunction&lt;Integer, Integer, Employee&gt; bf = Employee::new;bf.apply(10, 1000); //return new Employee(10, 1000); 注意： 需要调用的构造器参数列表要与函数式接口中抽象方法的参数列表保持一致。 3.3 数组引用语法格式： Type::new 1234567//lambdaFunction&lt;Integer, String[]&gt; function = (x) -&gt; new String[x];String[] apply = function.apply(10);//数组引用Function&lt;Integer, String[]&gt; function1 = String[]::new;String apply1 = function1.apply(10); //new String[10] 4. Stream APIStream API (java.util.stream.*) 4.1 创建 Stream 流 通过 Collection 的 stream(串行) 方法或者 parallelStream(并行) 方法创建集合流 12Stream&lt;String&gt; stream = list.stream();Stream&lt;String&gt; stringStream = list.parallelStream(); 通过 Arrays 的静态方法 stream 获取数组流 12Employee[] employees = new Employee[10];Stream&lt;Employee&gt; stream1 = Arrays.stream(employees); 通过 Stream 类的静态方法of获取流 1Stream&lt;String&gt; stream = Stream.of(\"aa\", \"bb\", \"cc\"); 创建无限流 迭代 1Stream&lt;Integer&gt; stream = Stream.iterate(0, x -&gt; x + 2); 生成 1Stream&lt;Double&gt; stream2 = Stream.generate(() -&gt; Math.random()); 4.2 中间操作多个中间操作可以连接起来形成一个流水线， 除非流水线上触发终止操作， 否则中间操作不会执行任何的处理！而在终止操作时一次性全部处理，称为“惰性求值”。 筛选与切片 方法 描述 filter(Predicate p) 接收 lambda, 从流中排除某些元素 distinct() 筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素(可能需要自己手动重写方法) limit(long maxSize) 截断流，使其元素不超过给定数量 skip(long n) 跳过元素， 返回一个扔掉了前n个元素的流。若流中元素不足n个， 则返回一个空流。与 limit(n) 互补。 映射 方法 描述 map 接收 lambda, 将元素转换成其他形式或提取信息， 接收一个函数作为参数，该函数会被应用到每个元素。 flatMap 接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流。 mapToInt(ToIntFunction f) 接收一个函数作为参数，该函数会被应用到每个元 素上，产生一个新的 IntStream。 mapToLong(ToLongFunction f) 接收一个函数作为参数，该函数会被应用到每个元 素上，产生一个新的 LongStream mapToDouble(ToDoubleFunction f) 接收一个函数作为参数，该函数会被应用到每个元 素上，产生一个新的 DoubleStream map 和 flatMap 类似于 List 的 add方法和 addAll 方法 排序 方法 描述 sorted() 自然排序 sorted(Comparator com) 定制排序 1234Comparator&lt;String&gt; comparator = (x,y) -&gt; x.length() - y.length(); list.stream() .sorted(comparator) .forEach(System.out::println); 4.3 终止操作终端操作会从流的流水线生成结果。其结果可以是任何不是流的值。例如：List, Integer, 甚至是 void。 查找和匹配 方法 描述 allMatch(Predicate p) 检查是否匹配所有元素 anyMatch(Predicate p) 检查是否至少匹配一个元素 noneMatch(Predicate p) 检查是否没有匹配所有元素 findFirst() 返回第一个元素 findAny() 返回当前流中的任意元素 count() 返回流中元素个数 max() 返回流中最大值 min() 返回流中最小值 Optional 1234Optional&lt;Employee&gt; op = employees.stream() .sorted((e1, e2) -&gt; -Double.compare(e1.getSalary(), e2.getSalary())) .findFirst(); //有可能为空就返回 OptionalSystem.out.println(op.get()); 规约 方法 描述 reduce(T identity, BinaryOperator) 可以将流中元素反复结合起来， 得到一个值。ideantity: 起始值， 返回值为 T reduce(BinaryOperator) 返回值为 Optinal ,因为没有起始值，可能为 null 12List&lt;Integer&gt; list = Arrays.asList(1,2,3,4,5,6,7);Integer sum = list.stream().reduce(0, (x, y) -&gt; x + y); map 和 reduce 的连接通常称为 map-reduce 模式, 因 Google 用它来进行网络搜索而出名。 收集 方法 描述 collect(Collector collector); collect(Supplier supplier, BiConsumer accumulator, BiConsumer combiner); Collector 接口中方法的实现决定了如何对流进行收集操作(如收集到List , Set, Map)。但是 Collectors 工具类提供了很多静态方法， 可以方便地创建常见收集器实例， 具体方法与实例如下表。 1234567891011121314151617181920212223242526272829303132//转化为 ListList&lt;String&gt; list = employees.stream().map(Employee::getUsername).collect(Collectors.toList());//转化为 SetSet&lt;Double&gt; set = employees.stream().map(Employee::getSalary).collect(Collectors.toSet());//转化为 HashSetHashSet&lt;String&gt; set1 = employees.stream().map(Employee::getUsername).collect(Collectors.toCollection(HashSet::new));//转化为 LinkedBlockingQueueLinkedBlockingQueue&lt;Employee&gt; queue = employees.stream().collect(Collectors.toCollection(LinkedBlockingQueue::new));//元素总数Long sum = employees.stream().collect(Collectors.counting());//工资平均值Double avg = employees.stream().collect(Collectors.averagingDouble(Employee::getSalary));//总和Double sum1 = employees.stream().collect(Collectors.summingDouble(Employee::getSalary));//最大值Optional&lt;Employee&gt; max = employees.stream().collect(Collectors.maxBy((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary())));//最小值Optional&lt;Employee&gt; min = employees.stream().collect(Collectors.maxBy((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary())));//分组Map&lt;Employee.Status, List&lt;Employee&gt;&gt; map = employees.stream().collect(Collectors.groupingBy(Employee::getStatus));System.out.println(map);//字符串拼接String str = employees.stream().map(Employee::getUsername).collect(Collectors.joining(\",\"));System.out.println(str);//多级分组Map&lt;Employee.Status, Map&lt;String, List&lt;Employee&gt;&gt;&gt; map1 = employees.stream().collect(Collectors.groupingBy(Employee::getStatus, Collectors.groupingBy(x -&gt; x.getAge() &gt; 30 ? \"青年\" : \"少年\")));System.out.println(map1);//分区Map&lt;Boolean, List&lt;Employee&gt;&gt; map2 = employees.stream().collect(Collectors.partitioningBy(x -&gt; x.getAge() &gt; 33));//一次得到最大值，最小值，平均值...DoubleSummaryStatistics summary = employees.stream().collect(Collectors.summarizingDouble(Employee::getSalary));System.out.println(summary.getMax()); 5 ​​并行流和串行流并行流就是把一个内容分成多个数据块， 并用不同的线程分别处理每个数据块的流。 java8 中将并行进行了优化， 我们可以很容易的对数据进行并行操作。``Stream API可以声明性地通过parallel()与sequential()` 在并行流与顺序流之间进行切换。 5.1 fork/join 框架Fork/Join 框架： 就是在必要的情况下，将一个大任务，进行拆分(fork)成若干个小任务（拆到不可再拆时），再将一个个的小任务运算的结果进行 join 汇总 。（类似于分治算法） 和线程池区别采用 “工作窃取”模式（work-stealing）：当执行新的任务时它可以将其拆分分成更小的任务执行，并将小任务加到线程队列中，然后再从一个随机线程的队列中偷一个并把它放在自己的队列中。 相对于一般的线程池实现,fork/join框架的优势体现在对其中包含的任务的处理方式上。在一般的线程池中,如果一个线程正在执行的任务由于某些原因无法继续运行,那么该线程会处于等待状态。而在fork/join框架实现中,如果某个子问题由于等待另外一个子问题的完成而无法继续运行，那么处理该子问题的线程会主动寻找其他尚未运行的子问题来执行。这种方式减少了线程的等待时间,提高了性能 。 fork/join 使用例子1234567891011121314151617181920212223242526272829303132333435363738public class ForkJoinCalcalue extends RecursiveTask&lt;Long&gt; &#123; private long start; private long end; private static final long THRESHOLD = 10000; public ForkJoinCalcalue(long start, long end) &#123; this.start = start; this.end = end; &#125; @Override protected Long compute() &#123; long length = end - start; //小于临界值进行累加 if (length &lt;= THRESHOLD) &#123; long sum = 0; for (long i = start; i &lt;= end; i++) &#123; sum += i; &#125; return sum; &#125; else &#123; long mid = start + ((end - start) &gt;&gt; 1); ForkJoinCalcalue left = new ForkJoinCalcalue(start, mid); //拆分子任务，同时压入线程队列 left.fork(); ForkJoinCalcalue right = new ForkJoinCalcalue(mid + 1, end); right.fork(); //合并 return left.join() + right.join(); &#125; &#125;&#125;//调用ForkJoinPool pool = new ForkJoinPool();ForkJoinTask&lt;Long&gt; task = new ForkJoinCalcalue(0, 100000000000L);Long sum = pool.invoke(task); 在java8后，对其进行了简化，java8的并行流底层就是 fork/join, 简化代码： 123OptionalLong sum = LongStream.rangeClosed(0, 100000000000L) .parallel() .reduce(Long::sum); 6 Optional 类Optional&lt;T&gt; 类(java.util.Optional) 是一个容器类，代表一个值存在或不存在，原来用 null表示一个值不存在，现在 Optional 可以更好的表达这个概念。并且可以避免空指针异常。 常用方法： 12345678Optional.of(T t) : 创建一个 Optional 实例Optional.empty() : 创建一个空的 Optional 实例Optional.ofNullable(T t):若 t 不为 null,创建 Optional 实例,否则创建空实例isPresent() : 判断是否包含值orElse(T t) : 如果调用对象包含值，返回该值，否则返回torElseGet(Supplier s) :如果调用对象包含值，返回该值，否则返回 s 获取的值map(Function f): 如果有值对其处理，并返回处理后的Optional，否则返回 Optional.empty()flatMap(Function mapper):与 map 类似，要求返回值必须是Optional 7 默认方法和静态方法Java 8中允许接口中包含具有具体实现的方法，该方法称为“默认方法”，默认方法使用 default 关键字修饰。 接口默认方法的” 类优先” 原则若一个接口中定义了一个默认方法，而另外一个父类或接口中又定义了一个同名的方法时。 选择父类中的方法。如果一个父类提供了具体的实现，那么接口中具有相同名称和参数的默认方法会被忽略。 接口冲突。如果一个父接口提供一个默认方法，而另一个接口也提供了一个具有相同名称和参数列表的方法（不管方法是否是默认方法）， 那么必须覆盖该方法来解决冲突","categories":[{"name":"java","slug":"java","permalink":"http://zfitness.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://zfitness.github.io/tags/java/"}]},{"title":"tools","slug":"tools","date":"2020-02-25T02:34:49.000Z","updated":"2020-02-25T04:01:59.596Z","comments":true,"path":"2020/02/25/tools/","link":"","permalink":"http://zfitness.github.io/2020/02/25/tools/","excerpt":"","text":"我的win10常用工具","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"http://zfitness.github.io/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-02-25T02:34:35.804Z","updated":"2020-02-25T02:34:35.804Z","comments":true,"path":"2020/02/25/hello-world/","link":"","permalink":"http://zfitness.github.io/2020/02/25/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"docker 学习笔记","slug":"docker","date":"2020-02-25T02:34:35.804Z","updated":"2020-02-29T02:59:39.228Z","comments":true,"path":"2020/02/25/docker/","link":"","permalink":"http://zfitness.github.io/2020/02/25/docker/","excerpt":"","text":"1 Docker简介1.1 什么是虚拟化​ 在计算机中，虚拟化（英语：Virtualization）是一种资源管理技术，是将计算机的各种实体资源，如服务器、网络、内存及存储等，予以抽象、转换后呈现出来，打破实体结构间的不可切割的障碍，使用户可以比原本的组态更好的方式来应用这些资源。这些资源的新虚拟部份是不受现有资源的架设方式，地域或物理组态所限制。一般所指的虚拟化资源包括计算能力和资料存储。 ​ 在实际的生产环境中，虚拟化技术主要用来解决高性能的物理硬件产能过剩和老的旧的硬件产能过低的重组重用，透明化底层物理硬件，从而最大化的利用物理硬件 对资源充分利用 ​ 虚拟化技术种类很多，例如：软件虚拟化、硬件虚拟化、内存虚拟化、网络虚拟化(vip)、桌面虚拟化、服务虚拟化、虚拟机等等。 1.2 什么是Docker​ Docker 是一个开源项目，诞生于 2013 年初，最初是 dotCloud 公司内部的一个业余项目。它基于 Google 公司推出的 Go 语言实现。 项目后来加入了 Linux 基金会，遵从了 Apache 2.0 协议，项目代码在 GitHub 上进行维护。 ​ ​ Docker 自开源后受到广泛的关注和讨论，以至于 dotCloud 公司后来都改名为 Docker Inc。Redhat 已经在其 RHEL6.5 中集中支持 Docker；Google 也在其 PaaS 产品中广泛应用。 ​ Docker 项目的目标是实现轻量级的操作系统虚拟化解决方案。 Docker 的基础是 Linux 容器（LXC）等技术。 ​ 在 LXC 的基础上 Docker 进行了进一步的封装，让用户不需要去关心容器的管理，使得操作更为简便。用户操作 Docker 的容器就像操作一个快速轻量级的虚拟机一样简单。 为什么选择Docker? （1）上手快。 ​ 用户只需要几分钟，就可以把自己的程序“Docker化”。Docker依赖于“写时复制”（copy-on-write）模型，使修改应用程序也非常迅速，可以说达到“随心所致，代码即改”的境界。 随后，就可以创建容器来运行应用程序了。大多数Docker容器只需要不到1秒中即可启动。由于去除了管理程序的开销，Docker容器拥有很高的性能，同时同一台宿主机中也可以运行更多的容器，使用户尽可能的充分利用系统资源。（2）职责的逻辑分类 ​ 使用Docker，开发人员只需要关心容器中运行的应用程序，而运维人员只需要关心如何管理容器。Docker设计的目的就是要加强开发人员写代码的开发环境与应用程序要部署的生产环境一致性。从而降低那种“开发时一切正常，肯定是运维的问题（测试环境都是正常的，上线后出了问题就归结为肯定是运维的问题）” （3）快速高效的开发生命周期 ​ Docker的目标之一就是缩短代码从开发、测试到部署、上线运行的周期，让你的应用程序具备可移植性，易于构建，并易于协作。（通俗一点说，Docker就像一个盒子，里面可以装很多物件，如果需要这些物件的可以直接将该大盒子拿走，而不需要从该盒子中一件件的取。） （4）鼓励使用面向服务的架构 ​ Docker还鼓励面向服务的体系结构和微服务架构。Docker推荐单个容器只运行一个应用程序或进程，这样就形成了一个分布式的应用程序模型，在这种模型下，应用程序或者服务都可以表示为一系列内部互联的容器，从而使分布式部署应用程序，扩展或调试应用程序都变得非常简单，同时也提高了程序的内省性。（当然，可以在一个容器中运行多个应用程序） 1.3 容器与虚拟机比较​ 下面的图片比较了 Docker 和传统虚拟化方式的不同之处，可见容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，而传统方式则是在硬件层面实现。 与传统的虚拟机相比，Docker优势体现为启动速度快、占用体积小。 1.4 Docker 组件1.4.1 Docker服务器与客户端​ Docker是一个客户端-服务器（C/S）架构程序。Docker客户端只需要向Docker服务器或者守护进程发出请求，服务器或者守护进程将完成所有工作并返回结果。Docker提供了一个命令行工具Docker以及一整套RESTful API。你可以在同一台宿主机上运行Docker守护进程和客户端，也可以从本地的Docker客户端连接到运行在另一台宿主机上的远程Docker守护进程。 1.4.2 Docker镜像与容器​ 镜像是构建Docker的基石。用户基于镜像来运行自己的容器。镜像也是Docker生命周期中的“构建”部分。镜像是基于联合文件系统的一种层式结构，由一系列指令一步一步构建出来。例如： 添加一个文件； 执行一个命令； 打开一个窗口。 也可以将镜像当作容器的“源代码”。镜像体积很小，非常“便携”，易于分享、存储和更新。 ​ Docker可以帮助你构建和部署容器，你只需要把自己的应用程序或者服务打包放进容器即可。容器是基于镜像启动起来的，容器中可以运行一个或多个进程。我们可以认为，镜像是Docker生命周期中的构建或者打包阶段，而容器则是启动或者执行阶段。 容器基于镜像启动，一旦容器启动完成后，我们就可以登录到容器中安装自己需要的软件或者服务。 所以Docker容器就是： ​ 一个镜像格式； ​ 一些列标准操作； ​ 一个执行环境。 ​ Docker借鉴了标准集装箱的概念。标准集装箱将货物运往世界各地，Docker将这个模型运用到自己的设计中，唯一不同的是：集装箱运输货物，而Docker运输软件。 和集装箱一样，Docker在执行上述操作时，并不关心容器中到底装了什么，它不管是web服务器，还是数据库，或者是应用程序服务器什么的。所有的容器都按照相同的方式将内容“装载”进去。 Docker也不关心你要把容器运到何方：我们可以在自己的笔记本中构建容器，上传到Registry，然后下载到一个物理的或者虚拟的服务器来测试，在把容器部署到具体的主机中。像标准集装箱一样，Docker容器方便替换，可以叠加，易于分发，并且尽量通用。1.4.3 Registry（注册中心）​ Docker用Registry来保存用户构建的镜像。Registry分为公共和私有两种。Docker公司运营公共的Registry叫做Docker Hub。用户可以在Docker Hub注册账号，分享并保存自己的镜像（说明：在Docker Hub下载镜像巨慢，可以自己构建私有的Registry）。 ​ https://hub.docker.com/ 2 Docker安装与启动2.1 安装Docker​ Docker官方建议在Ubuntu中安装，因为Docker是基于Ubuntu发布的，而且一般Docker出现的问题Ubuntu是最先更新或者打补丁的。在很多版本的CentOS中是不支持更新最新的一些补丁包的。 ​ 注意：这里建议安装在CentOS7.x以上的版本，在CentOS6.x的版本中，安装前需要安装其他很多的环境而且Docker很多补丁不支持更新。 daocloud 提供的安装方式： daocloud Centos7.x镜像 : （1）yum 包更新到最新 1sudo yum update （2）安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的 1sudo yum install -y yum-utils device-mapper-persistent-data lvm2 （3）设置yum源为阿里云 1sudo yum-config-manager --add-repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo （4）安装docker 1sudo yum install docker-ce （5）安装后查看docker版本 1docker -v 2.2 换源docker 官方源在国内是非常慢的，国内比较好用的源是 daocloud. 一键换源脚本 https://www.daocloud.io/mirror#accelerator-doc 手动换源 更改docker 的源配置文件： 1vi &#x2F;etc&#x2F;docker&#x2F;daemon.json 在该文件中输入如下内容： 123&#123;&quot;registry-mirrors&quot;: [&quot;http:&#x2F;&#x2F;f1361db2.m.daocloud.io&quot;]&#125; 2.3 Docker的启动与停止systemctl命令是系统服务管理器指令 启动docker： 1systemctl start docker 停止docker： 1systemctl stop docker 重启docker： 1systemctl restart docker 查看docker状态： 1systemctl status docker 开机启动： 1systemctl enable docker 查看docker概要信息 1docker info 查看docker帮助文档 1docker --help 3 常用命令3.1 镜像相关命令3.1.1 查看镜像1docker images REPOSITORY：镜像名称 TAG：镜像标签 IMAGE ID：镜像ID CREATED：镜像的创建日期（不是获取该镜像的日期） SIZE：镜像大小 这些镜像都是存储在Docker宿主机的/var/lib/docker目录下 3.1.2 搜索镜像如果你需要从网络中查找需要的镜像，可以通过以下命令搜索 1docker search 镜像名称 NAME：仓库名称 DESCRIPTION：镜像描述 STARS：用户评价，反应一个镜像的受欢迎程度 OFFICIAL：是否官方 AUTOMATED：自动构建，表示该镜像由Docker Hub自动构建流程创建的 3.1.3 拉取镜像拉取镜像就是从中央仓库中下载镜像到本地 1docker pull 镜像名称 例如，我要下载centos7镜像 1docker pull centos:7 3.1.4 删除镜像按镜像ID删除镜像 1docker rmi 镜像ID 删除所有镜像 1docker rmi &#96;docker images -q&#96; 不能删除问题，是由于多个镜像id相同， 可以直接用名称删除. 1docker rmi 192.168.1.111&#x2F;centos&#x2F;centos:7.2 必须先把镜像创建的容器全部删除才能删除镜像。 3.2 容器相关命令3.2.1 查看容器查看正在运行的容器 1docker ps 查看所有容器 1docker ps –a 查看最后一次运行的容器 1docker ps –l 查看停止的容器 1docker ps -f status&#x3D;exited 查看容器日志 1docker logs 3.2.2 创建与启动容器创建容器常用的参数说明： 创建容器命令：docker run -i：表示运行容器 -t：表示容器启动后会进入其命令行。加入这两个参数后，容器创建就能登录进去。即分配一个伪终端。 –name :为创建的容器命名。 -v：表示目录映射关系（前者是宿主机目录，后者是映射到宿主机上的目录），可以使用多个－v做多个目录或文件映射。注意：最好做目录映射，在宿主机上做修改，然后共享到容器上。 -d：在run后面加上-d参数,则会创建一个守护式容器在后台运行（这样创建容器后不会自动登录容器，如果只加-i -t两个参数，创建后就会自动进去容器）。 -p：表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个-p做多个端口映射 （1）交互式方式创建容器 容器的name 必须唯一 1docker run -it --name&#x3D;容器名称 镜像名称:标签 &#x2F;bin&#x2F;bash 这时我们通过ps命令查看，发现可以看到启动的容器，状态为启动状态 退出当前容器 1exit （2）守护式方式创建容器： 1docker run -di --name&#x3D;容器名称 镜像名称:标签 登录守护式容器方式： 1docker exec -it 容器名称 (或者容器ID) &#x2F;bin&#x2F;bash 3.2.3 停止与启动容器停止容器： 1docker stop 容器名称（或者容器ID） 启动容器： 1docker start 容器名称（或者容器ID） 3.2.4 文件拷贝如果我们需要将文件拷贝到容器内可以使用cp命令 1docker cp 需要拷贝的文件或目录 容器名称:容器目录 也可以将文件从容器内拷贝出来 1docker cp 容器名称:容器需要拷贝的文件或目录 文件名 3.2.5 目录挂载我们可以在创建容器的时候，将宿主机的目录与容器内的目录进行映射，这样我们就可以通过修改宿主机某个目录的文件从而去影响容器。创建容器 添加-v参数 后边为 宿主机目录:容器目录，例如： 1docker run -di -v &#x2F;usr&#x2F;local&#x2F;myhtml:&#x2F;usr&#x2F;local&#x2F;myhtml --name&#x3D;mycentos3 centos:7 如果你共享的是多级的目录，可能会出现权限不足的提示。 这是因为CentOS7中的安全模块selinux把权限禁掉了，我们需要添加参数 –privileged=true 来解决挂载的目录没有权限的问题 3.2.6 查看容器IP地址我们可以通过以下命令查看容器运行的各种数据 1docker inspect 容器名称（容器ID） 也可以直接执行下面的命令直接输出IP地址 1docker inspect --format&#x3D;&#39;&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;&#39; 容器名称（容器ID） 3.2.7 删除容器删除指定的容器： 必须先把容器停止才能删除。 1docker rm 容器名称（容器ID） 删除所有停止容器 1docker container prune 4 应用部署4.1 MySQL部署（1）拉取mysql镜像 1docker pull centos&#x2F;mysql-57-centos7 （2）创建容器 1docker run -di --name&#x3D;tensquare_mysql -p 33306:3306 -e MYSQL_ROOT_PASSWORD&#x3D;123456 mysql -p 代表端口映射，格式为 宿主机映射端口:容器运行端口 -e 代表添加环境变量 MYSQL_ROOT_PASSWORD 是root用户的登陆密码 （3）远程登录mysql 连接宿主机的IP ,指定端口为33306 4.2 tomcat部署（1）拉取镜像 1docker pull tomcat:7-jre7 （2）创建容器 创建容器 -p表示地址映射 12docker run -di --name&#x3D;mytomcat -p 9000:8080 -v &#x2F;usr&#x2F;local&#x2F;webapps:&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;webapps tomcat:7-jre7 4.3 Nginx部署（1）拉取镜像 1docker pull nginx （2）创建Nginx容器 1docker run -di --name&#x3D;mynginx -p 80:80 nginx 4.4 Redis部署（1）拉取镜像 1docker pull redis （2）创建容器 1docker run -di --name&#x3D;myredis -p 6379:6379 redis 4.5 RabbitMQ 部署 拉取镜像 1docker pull daocloud.io/library/rabbitmq:3.7.14-management-alpine 创建容器 1docker run -d --hostname my-rabbit --name rabbit -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=admin -p 8080:15672 -p 5672:5672 -p 25672:25672 -p 61613:61613 -p 1883:1883 daocloud.io/library/rabbitmq:3.7.14-management-alpine 15672：控制台端口号（浏览器访问的地址) 5672：应用访问端口号， 使用java连接时的地址 RABBITMQ_DEFAULT_USER : rabbitmq 用户名 RABBITMQ_DEFAULT_PASS : rabbitmq 密码 5 迁移与备份5.1 容器保存为镜像我们可以通过以下命令将容器保存为镜像 1docker commit mynginx mynginx_i 5.2 镜像备份我们可以通过以下命令将镜像保存为tar 文件 1docker save -o mynginx.tar mynginx_i 5.3 镜像恢复与迁移首先我们先删除掉mynginx_img镜像 然后执行此命令进行恢复 1docker load -i mynginx.tar -i 输入的文件 执行后再次查看镜像，可以看到镜像已经恢复 6 Dockerfile6.1 什么是DockerfileDockerfile是由一系列命令和参数构成的脚本，这些命令应用于基础镜像并最终创建一个新的镜像。 1、对于开发人员：可以为开发团队提供一个完全一致的开发环境；2、对于测试人员：可以直接拿开发时所构建的镜像或者通过Dockerfile文件构建一个新的镜像开始工作了；3、对于运维人员：在部署时，可以实现应用的无缝移植。 6.2 常用命令 命令 作用 FROM image_name:tag 定义了使用哪个基础镜像启动构建流程 MAINTAINER user_name 声明镜像的创建者 ENV key value 设置环境变量 (可以写多条) RUN command 是Dockerfile的核心部分(可以写多条) ADD source_dir/file dest_dir/file 将宿主机的文件复制到容器内，如果是一个压缩文件，将会在复制后自动解压 COPY source_dir/file dest_dir/file 和ADD相似，但是如果有压缩文件并不能解压 WORKDIR path_dir 设置工作目录 6.3 使用脚本创建镜像步骤： （1）创建目录 1mkdir –p &#x2F;usr&#x2F;local&#x2F;dockerjdk8 （2）下载jdk-8u171-linux-x64.tar.gz并上传到服务器（虚拟机）中的/usr/local/dockerjdk8目录 （3）创建文件Dockerfile vi Dockerfile 123456789101112131415#依赖镜像名称和IDFROM centos:7#指定镜像创建者信息MAINTAINER zm#切换工作目录WORKDIR &#x2F;usrRUN mkdir &#x2F;usr&#x2F;local&#x2F;java#ADD 是相对路径jar,把java添加到容器中ADD jdk-8u171-linux-x64.tar.gz &#x2F;usr&#x2F;local&#x2F;java&#x2F;#配置java环境变量ENV JAVA_HOME &#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.8.0_171ENV JRE_HOME $JAVA_HOME&#x2F;jreENV CLASSPATH $JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jar:$JRE_HOME&#x2F;lib:$CLASSPATHENV PATH $JAVA_HOME&#x2F;bin:$PATH （4）执行命令构建镜像 1docker build -t&#x3D;&#39;jdk1.8&#39; . 注意后边的空格和点，不要省略 （5）查看镜像是否建立完成 1docker images 7 Docker私有仓库7.1 私有仓库搭建与配置这个镜像版本是2.x 以上的。 （1）拉取私有仓库镜像（此步省略） 1docker pull registry （2）启动私有仓库容器 1docker run -di --name&#x3D;registry -p 5000:5000 registry （3）打开浏览器 输入地址http://192.168.184.141:5000/v2/_catalog看到`{&quot;repositories&quot;:[]}` 表示私有仓库搭建成功并且内容为空 （4）修改daemon.json 1vi &#x2F;etc&#x2F;docker&#x2F;daemon.json 添加以下内容，保存退出。 123456&#123; //镜像源\"registry-mirrors\": [\"http://f1361db2.m.daocloud.io\"], //私有仓库地址\"insecure-registries\":[\"http://192.168.80.129:5000\"]&#125; 此步用于让 docker信任私有仓库地址 （5）重启docker 服务 1systemctl restart docker 7.2 镜像上传至私有仓库（1）标记此镜像为私有仓库的镜像 1docker tag jdk1.8 192.168.184.141:5000&#x2F;jdk1.8 （2）再次启动私服容器 1docker start registry （3）上传标记的镜像 一定要指定私服地址 1docker push 192.168.184.141:5000&#x2F;jdk1.8 8 Docker 远程访问 修改宿主机的docker配置，让其可以远程访问vi /lib/systemd/system/docker.service其中ExecStart=后添加配置 1ExecStart&#x3D;&#x2F;usr&#x2F;bin&#x2F;dockerd -H tcp:&#x2F;&#x2F;0.0.0.0:2375 -H unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock 刷新配置，重启服务 123systemctl daemon‐reloadsystemctl restart dockerdocker start registry 测试 浏览器打开 http://ip:2375/images/json 使用 docker -H ip info 在 idea 里面使用","categories":[{"name":"docker","slug":"docker","permalink":"http://zfitness.github.io/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://zfitness.github.io/tags/docker/"}]},{"title":"test","slug":"test","date":"2020-02-12T12:54:02.000Z","updated":"2020-02-25T02:34:35.820Z","comments":true,"path":"2020/02/12/test/","link":"","permalink":"http://zfitness.github.io/2020/02/12/test/","excerpt":"","text":"","categories":[],"tags":[]}]}